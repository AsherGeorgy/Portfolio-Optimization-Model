# Visualization.py

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import plotly.express as px
import seaborn as sns

from utils.optimization import portfolio_stats


def opt_portfolio_results(optimal_weights, returns_assets, returns_assets_ann, returns_assets_cov, risk_free_rate, assets_list, returns_benchmark, benchmark_index, benchmark_name, target_cagr_valid):
    """
    Displays the results of the portfolio optimization if the optimal weights are valid.
    """
    # Return if weights are invalid
    if optimal_weights is None or np.any(np.isnan(optimal_weights)):
        st.warning("Optimal weights are invalid. Please check your inputs.")
        return

    # Calculate stats of portfolio with optimal weights
    optimal_portfolio_return, optimal_portfolio_volatility, optimal_sharpe_ratio = portfolio_stats(optimal_weights, returns_assets_ann, returns_assets_cov, risk_free_rate)

    # Create a DataFrame for weights with better formatting
    results_df = pd.DataFrame({
        "Asset": assets_list,
        "Weight": [f"{weight * 100:.2f}%" for weight in optimal_weights]  # Format weights as percentages
    })

    # Set 'Asset' column as the index
    results_df.set_index('Asset', inplace=True)

    st.markdown(f"The portfolio allocation, optimized to meet the <span style='color: #003366;'><b>target CAGR of {target_cagr_valid * 100:.2f}% while minimizing volatility</b></span>, based on historical data, is as follows:", unsafe_allow_html=True)
    # Display the weights table
    st.write(results_df.T)

    # Prepare cumulative returns for plotting
    cumprod_df = returns_benchmark.copy()
    cumprod_df.rename(columns={benchmark_index: benchmark_name}, inplace=True)

    if optimal_weights is not None and not np.any(np.isnan(optimal_weights)):
        pfolio_returns_at_optimal_weights = returns_assets.values @ optimal_weights
        cumprod_df['Optimized Portfolio'] = pfolio_returns_at_optimal_weights

    # Calculate cumulative returns
    cumprod_df = (1 + cumprod_df).cumprod()

    st.markdown(f"Hereâ€™s how the optimized portfolio performed in a backtest over the period of analysis:")
    # Create two columns for side-by-side layout
    col1, col2 = st.columns([2, 6])  # Adjust column width ratio if needed

    with col1:
        # Display portfolio statistics using st.metric() with delta or custom formatting
        st.metric(label="CAGR", value=f"{optimal_portfolio_return * 100:.2f}%")
        st.metric(label="Average Annual Volatility", value=f"{optimal_portfolio_volatility * 100:.2f}%")
        st.metric(label="Sharpe Ratio", value=f"{optimal_sharpe_ratio:.4f}")

    with col2:
        # Display the cumulative returns chart
        st.line_chart(cumprod_df, use_container_width=True, x_label=f"Optimized Portfolio compared to {benchmark_name} over the period of analysis.")

    st.write('________________________________________________________________________')


def visualize_analyses(pfolio_volatility, pfolio_return, weights, sharpe_ratios, returns_assets, optimal_weights, returns_benchmark, benchmark_name, benchmark_index, no_of_iterations, assets_list, returns_assets_ann, returns_all_corr, returns_assets_cov, risk_free_rate):
    """
    Visualizes portfolio analysis results in a Streamlit app, including the efficient frontier, identified portfolios, and their relative daily return movements.
    """
    # Identify relevant portfolios
    min_volatility_idx = np.argmin(pfolio_volatility)
    max_return_idx = np.argmax(pfolio_return)
    max_sharpe_idx = np.argmax(sharpe_ratios)

    # Calculate daily portfolio returns
    pfolio_returns_at_max_sharpe_weights = returns_assets.values @ weights[max_sharpe_idx]
    pfolio_returns_at_min_vol_weights = returns_assets.values @ weights[min_volatility_idx]
    pfolio_returns_at_max_ret_weights = returns_assets.values @ weights[max_return_idx]


    # Outputs
    # Section Title
    st.markdown("<h2 style='color: #003366;'><u>Modern Portfolio Theory</u></h2>", unsafe_allow_html=True)
   
    # Create tabs for different sections
    tab1, tab2, tab3, tab4 = st.tabs(["Efficient Frontier", "Portfolio Allocation","Performance Comparison", "Constituent Assets"])

    # Efficient Frontier Analysis
    with tab1:
        # Efficient Frontier Plot
        st.markdown("<h3 style='color: #003366;'>Efficient Frontier</h3>", unsafe_allow_html=True)
        st.markdown("""
            The following plot visualizes the efficient frontier generated by Monte Carlo simulations, showing the relationship between 
            portfolio return and volatility.
        """)
        # Display the number of Monte Carlo simulation runs
        st.markdown(f"**Number of Monte Carlo simulation runs:** <span style='color: #003366;'>{no_of_iterations}</span>", unsafe_allow_html=True)
        fig = go.Figure()

        # Add all portfolios scatter plot
        fig.add_trace(go.Scatter(
            x=pfolio_volatility,
            y=pfolio_return,
            mode='markers',
            name='All Portfolios',
            marker=dict(
                color=sharpe_ratios,
                colorscale='Viridis',
                size=6,
                showscale=True,
                colorbar=dict(title="Sharpe Ratio")
            )
        ))

        # Highlight Min Volatility Portfolio
        fig.add_trace(go.Scatter(
            x=[pfolio_volatility[min_volatility_idx]],
            y=[pfolio_return[min_volatility_idx]],
            mode='markers+text',
            name='Min Volatility',
            marker=dict(color='green', size=10),
            text='Min Volatility',
            textposition='top center'
        ))

        # Highlight Max Return Portfolio
        fig.add_trace(go.Scatter(
            x=[pfolio_volatility[max_return_idx]],
            y=[pfolio_return[max_return_idx]],
            mode='markers+text',
            name='Max Return',
            marker=dict(color='blue', size=10),
            text='Max Return',
            textposition='top center'
        ))

        # Highlight Max Sharpe Ratio Portfolio
        fig.add_trace(go.Scatter(
            x=[pfolio_volatility[max_sharpe_idx]],
            y=[pfolio_return[max_sharpe_idx]],
            mode='markers+text',
            name='Max Sharpe Ratio',
            marker=dict(color='red', size=10),
            text='Max Sharpe',
            textposition='top center'
        ))

        # Update layout for better visualization
        fig.update_layout(
            xaxis_title='Volatility (%)',
            yaxis_title='Return (%)',
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            ),
            template='plotly_white'
        )

        # Render Efficient Frontier plot
        st.plotly_chart(fig, use_container_width=True)

        st.markdown("""
            Modern Portfolio Theory (MPT) identifies key portfolios on the efficient frontier, 
            including the **maximum return portfolio**, the **minimum volatility portfolio**, and the 
            **maximum Sharpe ratio portfolio**, each representing different trade-offs between 
            risk and return. MPT underscores the importance of asset diversification to 
            achieve the optimal balance between risk and return.
        """)
    
    # Portfolio Allocation
    with tab2:
        # Prepare data for Portfolio Weights and Metrics Table
        table2_data = {
            "Portfolio": [
                "Maximum Return Portfolio", 
                "Minimum Volatility Portfolio", 
                "Maximum Sharpe Ratio Portfolio"
            ],
            **{ticker: [] for ticker in assets_list},  
            "Portfolio Return": [],
            "Portfolio Volatility": [],
            "Portfolio Sharpe Ratio": [],
        }

        # Define portfolios and their corresponding weights
        portfolios = [
            ("Maximum Return Portfolio", weights[np.argmax(pfolio_return)]),
            ("Minimum Volatility Portfolio", weights[np.argmin(pfolio_volatility)]),
            ("Maximum Sharpe Ratio Portfolio", weights[np.argmax(sharpe_ratios)]),
        ]

        # Populate the table with data
        for name, portfolio_weights in portfolios:
            portfolio_return, portfolio_volatility, portfolio_sharpe = portfolio_stats(
                portfolio_weights, returns_assets_ann, returns_assets_cov, risk_free_rate
            )
            for i, ticker in enumerate(assets_list):
                table2_data[ticker].append(f"{portfolio_weights[i]:.2f}")  
            table2_data["Portfolio Return"].append(f"{portfolio_return * 100:.2f}%")
            table2_data["Portfolio Volatility"].append(f"{portfolio_volatility * 100:.2f}%")
            table2_data["Portfolio Sharpe Ratio"].append(f"{portfolio_sharpe:.4f}")

        # Display the table 
        st.markdown("<h3 style='color: #003366;'>Portfolio Allocation</h3>", unsafe_allow_html=True)

        st.markdown("""
            The table below presents three portfolios based on MPT, along with their 
            corresponding asset weights and historical performance metrics.
        """)

        # Convert the table data into a pandas DataFrame for better control over styling
        table2_df = pd.DataFrame(table2_data)

        # Display the table with index (Portfolio) as rows
        st.write(table2_df.set_index("Portfolio"))

    # Performance comparison
    with tab3: 

        # Prepare cumulative product of returns for comparison
        cumprod_df = returns_benchmark.copy()
        cumprod_df.rename(columns={benchmark_index: benchmark_name}, inplace=True)
        cumprod_df['Maximum Sharpe Ratio Portfolio'] = pfolio_returns_at_max_sharpe_weights
        cumprod_df['Minimum Volatility Portfolio'] = pfolio_returns_at_min_vol_weights
        cumprod_df['Maximum Return Portfolio'] = pfolio_returns_at_max_ret_weights

        # Cumulative returns calculation
        cumprod_df = (1 + cumprod_df).cumprod() - 1

        # Cumulative Returns Plot
        st.markdown("<h3 style='color: #003366;'>Performance Comparison</h3>", unsafe_allow_html=True)
        st.markdown(f"""
            The following plot shows the backtested cumulative performance of each of the portfolios identified, 
            compared to the {benchmark_name} index. 
        """)


        # Line Chart for cumulative returns comparison
        fig = px.line(
            cumprod_df,
            labels={"value": "Cumulative Return", "index": "Date"},
            line_shape='linear'
        )

        fig.update_traces(mode='lines', line=dict(width=2))

        fig.update_layout(
            xaxis_title="Date",
            yaxis_title="Cumulative Return (%)",
            template='plotly_white',
            plot_bgcolor='rgba(245, 245, 245, 0.85)',
            hovermode='x unified',
            hoverlabel=dict(bgcolor="white", font_size=12),
            legend=dict(
                x=0,                 # Move to left side
                y=1,                 # Move to top
                xanchor='left',
                yanchor='top',
                bgcolor='rgba(255, 255, 255, 0.7)',  # background color
                bordercolor='Black', 
                borderwidth=1        
            )
        )

        # Show the plot
        st.plotly_chart(fig, use_container_width=True)

    # Constituents
    with tab4:
       st.markdown("<h3 style='color: #003366;'>Constituent Assets</h3>", unsafe_allow_html=True)
       generate_asset_and_portfolio_tables(
        assets_list, 
        returns_assets_ann, 
        returns_assets, 
        risk_free_rate, 
        returns_all_corr
    ) 


def generate_asset_and_portfolio_tables(
    assets_list, 
    returns_assets_ann, 
    returns_assets, 
    risk_free_rate, 
    returns_all_corr
):
    # Prepare data for Table 1: Return, Volatility, Sharpe Ratio of Each Asset
    table1_data = {
        "Metric": ["Average Return", "Average Volatility", "Sharpe Ratio"]
    }
    
    for ticker in assets_list:
        asset_return = returns_assets_ann[ticker].mean()
        asset_volatility = returns_assets[ticker].std() * (250 ** 0.5)
        asset_sharpe = (asset_return - risk_free_rate) / asset_volatility

        table1_data[ticker] = [
            f"{asset_return * 100:.2f}%",  
            f"{asset_volatility * 100:.2f}%",  
            f"{asset_sharpe:.4f}", 
        ]

    # Display Table 1
    st.markdown("The table below shows the CAGR, Volatility and Sharpe Ratio of constituent assets over the period of analysis:")
    st.markdown("<h5 style='color: #003366;'>Asset Metrics</h5>", unsafe_allow_html=True)
    table1_df = pd.DataFrame(table1_data)
    st.write(table1_df.set_index("Metric"))

    # Correlation Heatmap
    st.markdown("<h5 style='color: #003366;'>Asset Correlation Heatmap:</h5>", unsafe_allow_html=True)
    fig = plt.figure(figsize=(15, 8))
    sns.heatmap(returns_all_corr, annot=True, cmap='coolwarm', fmt='.2f')
    st.pyplot(fig)  






